#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    //1.
    //push_back(value) : добавление элемента value в конец вектора

    //erase(p) или erase(begin, end) : удаляет элемент, на который указывает итератор p 
    //(удаляет элементы из диапазона, на начало и конец которого указывают итераторы begin и end.)

    //insert(pos, value) : вставляет элемент value на позицию, на которую указывает итератор pos, аналогично функции emplace
    //insert(pos, n, value) : вставляет n элементов value начиная с позиции, на которую указывает итератор pos
    //insert(pos, begin, end) : вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из диапазона между итераторами begin и end
    //insert(pos, values) : вставляет список значений начиная с позиции, на которую указывает итератор pos

    std::vector<int> vec1;     // пустой вектор
    vec1.push_back(5);
    vec1.push_back(3);
    for (int i = 0; i < vec1.size(); i++)
    {
        cout << vec1[i] << " ";
    }
    cout << "\nСоздали пустой вектор и добавили два элемента\n";
    vec1.push_back(10);
    for (int i = 0; i < vec1.size(); i++)
    {
        cout << vec1[i] << " ";
    }
   cout << "\nЭлемент '10' добавился в конец вектора\n\n";

   std::vector<int> vec2 = { 1, 2, 3, 4, 5, 6, 7 };
   auto iter = vec2.cbegin();
   vec2.erase(iter+1);
   for (int i = 0; i < vec2.size(); i++)
   {
       cout << vec2[i] << " ";
   }
   cout << "\nСоздали вектор { 1, 2, 3, 4, 5, 6, 7 } и удалили его 2-й элемент\n";
   vec2.erase(iter + 2, iter + 5);
   for (int i = 0; i < vec2.size(); i++)
   {
       cout << vec2[i] << " ";
   }
   cout << "\nУдалили элементы, начиная с 3-го до последнего\n\n";

   std::vector<int> vec3 = { 1, 2, 3, 4, 5, 6, 7 };
   auto iter3 = vec3.cbegin();
   vec3.insert(iter3 + 1, 1001);
   for (int i = 0; i < vec3.size(); i++)
   {
       cout << vec3[i] << " ";
   }
   cout << "\nСоздали вектор { 1, 2, 3, 4, 5, 6, 7 } и вставили элемент 1001 на 2-ю позицию\n";

   std::vector<int> vec4 = { 1, 2, 3, 4, 5, 6, 7 };
   auto iter4 = vec4.cbegin();
   vec4.insert(iter4 + 2, 3, 4);
   for (int i = 0; i < vec4.size(); i++)
   {
       cout << vec4[i] << " ";
   }
   cout << "\nВставили 3 четверки, начиная с 3 позиции\n";

   std::vector<int> vec5 = { 1, 2, 3, 4, 5, 6, 7 };
   std::vector<int> str = { 123, 456, 789, 0 };
   auto iter5 = vec5.cbegin();
   vec5.insert(iter5 + 1, str.begin(), str.end());
   for (int i = 0; i < vec5.size(); i++)
   {
       cout << vec5[i] << " ";
   }
   cout << "\nВставили элементы другого вектора ({ 123, 456, 789, 0 }) в исходный, начиная со 2-й позиции\n";

   std::vector<int> vec6 = { 1, 2, 3, 4, 5, 6, 7 };
   auto iter6 = vec6.cbegin();
   vec6.insert(iter6 + 2, { 555, 666, 777 });
   for (int i = 0; i < vec6.size(); i++)
   {
       cout << vec6[i] << " ";
   }
   cout << "\nВставили элементы контейнера { 555, 666, 777 } в вектор, начиная со 3-й позиции\n\n";

   /*2.
    emplace_back(value) : вставить элемент value в конец вектора*/

   std::vector<int> vec21 = { 1, 2, 3, 4, 5 };
   vec21.emplace_back(1234);
   for (int i = 0; i < vec21.size(); i++)
   {
       cout << vec21[i] << " ";
   }
   cout << "\nСоздали вектор { 1, 2, 3, 4, 5 } и добавили в его конец число 1234\n\n";

   /*
   3.
   resize(n) : оставляет в векторе n первых элементов.Если вектор содержит больше элементов, то его размер усекается до n элементов.Если размер вектора меньше n, 
   то добавляются недостающие элементы и инициализируются значением по умолчанию

   resize(n, value) : также оставляет в векторе n первых элементов.Если размер вектора меньше n, то добавляются недостающие элементы со значением value

   reserve(Newcapacity) : позволяет выделить(зарезервировать) память для элементов массива, Newcapacity – новый размер массива с учетом зарезервированных элементов.
   Правильное использование метода в программе позволяет ускорить выполнение программы в случаях, когда активно изменяется размер массива
   (часто выполняются операции добавления, удаления элементов из массива).
   Это осуществляется за счет уменьшения количества операций, связанных с перераспределением памяти.
   
   shrink_to_fit() :  уменьшает количество используемой памяти нашего вектора и возвращает её системе.
   
   capacity() : возвращает ёмкость вектора (количество выделенной по вектора памяти)*/

   std::vector<int> vec31 = { 1, 2, 3, 4, 5, 6 };
   vec31.resize(4);
   for (int i = 0; i < vec31.size(); i++)
   {
       cout << vec31[i] << " ";
   }
   cout << "\nСоздали вектор { 1, 2, 3, 4, 5, 6 } и уменьшили его размер до 4-х элементов\n";

   vec31.resize(6, 8);
   for (int i = 0; i < vec31.size(); i++)
   {
       cout << vec31[i] << " ";
   }
   cout << "\nУвеличили размер уменьшенного вектора до 6-х элементов и заполнили образовавшиеся пустые ячейки восьмёрками\n\n";

   std::vector<int> vec32 = { 1, 2, 3, 4, 5 };
   cout << "Создали вектор { 1, 2, 3, 4, 5 }, посмотрели его количество элементов и то, сколько он может содержать элементов\n";
   cout << vec32.size() << endl;
   cout << vec32.capacity() << endl;
   cout << "Выделили память под новые элементы, увидели текущее количество элементов и текущую вместимость вектора \n";
   vec32.reserve(12);
   cout << vec32.size() << endl;
   cout << vec32.capacity() << endl << endl;

   vector <int> vec33{ 1, 2, 3, 4, 5 };
   cout << "\nСоздали вектор { 1, 2, 3, 4, 5 }, посмотрели его количество элементов и то, сколько он может содержать элементов\n";
   cout << vec33.capacity();
   vec33.clear();
   cout << vec33.capacity();
   cout << "\nКоличество элементов, которое может содержать вектор после удаления всех элементов\n";
   vec33.shrink_to_fit();
   cout << vec33.capacity();
   cout << "\nРазмер вектора после очищения памяти (использование shrink_to_fit)\n\n";

   vector <int> vec34{ 1, 2, 3, 4, 5 };
   cout << "\nСоздали вектор { 1, 2, 3, 4, 5 } и увидели его вместимость\n";
   cout << vec34.capacity();
   vec34.pop_back();
   cout << "\nУдалили последний элемент вектора, однако ёмкость вектора осталась прежней\n";
   for (int i = 0; i < vec34.size(); i++)
       cout << vec34[i] << " ";
   cout << "\n" << vec34.capacity() << "\n\n";


   /*4.
   clear() : удаляет все элементы вектора. Длина вектора, которая возвращается методом size(), становится равной 0.*/

   vector <int> vec41{ 1, 2, 3, 4, 5 };
   cout << "\nСоздали вектор { 1, 2, 3, 4, 5 }\n";
   vec41.clear();
   cout << "\nУдалили все элементы\n";
   cout << "Размер вектора: " << vec41.size() << " Вместимость: " << vec41.capacity() << "\n\n";

   /*5.
   Оператор присваивания позволяет скопировать элементы одного вектора в другой, причём старые элементы вектора перезаписываются.

   К элементам вектора можно обращаться по числовым индексам с помощью оператора []. Как и в обычном массиве, первый элемент имеет индекс 0, последний — (размер вектора – 1).
   Кроме того, для обращения к первому и последнему элементам определены специальные функции front и back.
   Оператор [] по умолчанию не выполняет проверку допустимости значения индекса. Попытка обратиться к несуществующему элементу ведёт к неопределённому поведению. 
   Вместо [] можно использовать функцию at(), которая хотя также возвращает элемент по индексу, 
   но при попытке обращения по недопустимому индексу будет генерировать исключение out_of_range.*/

   vector <int> vec51{ 1, 2, 3, 4, 5 };
   vector <int> vec52{ 1, 2, 345, 34, 1, 24, 56346 };
   cout << "Создали два вектора { 1, 2, 3, 4, 5 } и { 1, 2, 345, 34, 1, 24, 56346 }\n";
   vec52 = vec51;
   for (int i = 0; i < vec52.size(); i++)
       cout << vec52[i] << " ";
   cout << "\nСкопировали элементы первого вектора во второй\n\n";

   vector <int> vec53{ 1, 2, 3, 4, 5 };
   cout << "Создали вектор { 1, 2, 3, 4, 5 }\n";
   cout << "Третий элемент: " << vec53[2] << " Первый элемент: " << vec53.front() << " Последний элемент: " << vec53.back() << " Обращение к несуществуещему 6-му элементу :" << endl;
   try
   {
       int n = vec53.at(6);
   }
   catch (out_of_range e)
   {
       cout << "Неверный индекс!" << endl;
   }
}
